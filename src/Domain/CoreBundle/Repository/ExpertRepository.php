<?php

namespace Domain\CoreBundle\Repository;

use Doctrine\ORM\EntityRepository;
use Doctrine\ORM\Query\Expr;
use Doctrine\ORM\QueryBuilder;
use Doctrine\ORM\Query\ResultSetMapping;
use Domain\CoreBundle\Entity\User;
use Domain\CoreBundle\Entity\Expert;
use iKantam\UtilsBundle\Utils\ArrayUtils;
use DateTime;

/**
 * ExpertRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class ExpertRepository extends EntityRepository
{
    /**
     * Find one active by id
     *
     * @param int $expertId
     *
     * @return object
     */
    public function findOneActiveById($expertId)
    {
        return $this->findOneBy(
            [
                'id' => $expertId,
                'active' => Expert::STATUS_ACTIVE
            ]
        );
    }

    /**
     * Get count of active experts
     *
     * @return int Count of active experts
     */
    public function activeCount()
    {
        $qb =  $this->createQueryBuilder('expert');
        $qb ->select($qb->expr()->count('expert.id'))
            ->innerJoin('expert.billing', 'billing')
            ->innerJoin('expert.user', 'user')
            ->where($qb->expr()->eq('expert.active', ':active_status'))
            ->andWhere($qb->expr()->eq('user.enabled', ':true'))
            ->andWhere($qb->expr()->eq('user.locked', ':false'))
            ->setParameters([
                'active_status' => Expert::STATUS_ACTIVE,
                'false' => 0,
                'true' => 1
                ]);
        ;

        return (int) $qb->getQuery()->getSingleScalarResult();
    }

    /**
     * Get expert ids by generated query builder
     *
     * @param QueryBuilder $qb
     *
     * @return array
     */
    public function getIdsByQuery(QueryBuilder $qb)
    {
        $_qb = clone $qb;
        $result = $_qb->select('expert.id')->distinct()->getQuery()->getArrayResult();
        $ids = array_map('current', $result);

        return $ids;
    }

    /**
     * Return QueryBuilder for searching experts
     *
     * @param User  $user
     * @param array $params
     * @param array $priceGroups
     *
     * @return QueryBuilder
     */
    public function searchQB(User $user = null, array $params = [], $priceGroups = [], $maxRating)
    {

        $qb = $this->createQueryBuilder('expert');

        $qb
            ->addSelect('info')
            ->addSelect('location')
            ->addSelect('industry')
            ->addSelect('user')

            ->innerJoin('expert.user', 'user')
            ->innerJoin('expert.billing', 'billing')

            ->leftJoin('expert.additional_info', 'info')
            ->leftJoin('expert.location', 'location')
            ->leftJoin('expert.industry', 'industry')
            ->leftJoin('expert.educations', 'educations')

            ->leftJoin('educations.institution', 'institution')
            ->leftJoin('expert.skills', 'skills')
            ->leftJoin('expert.experiences', 'experiences')
            ->leftJoin('experiences.company', 'company')

            ->where('expert.active = :active')

            ->andWhere($qb->expr()->eq('user.enabled', ':true'))
            ->andWhere($qb->expr()->eq('user.locked', ':false'))

            ->setParameter('active', Expert::STATUS_ACTIVE)
            ->setParameter('false', 0)
            ->setParameter('true', 1)
            ;

        if ($user) {
            $qb
                ->andWhere('user <> :user')
                ->setParameter('user', $user);
        }


        if (!empty($params['search'])) {

            $qb->andWhere(
                $qb->expr()->orX(
                    $qb->expr()->like('info.first_name', ':search'),
                    $qb->expr()->like('info.last_name', ':search'),
                    $qb->expr()->like('info.headline', ':search'),
                    $qb->expr()->like('location.name', ':search'),
                    $qb->expr()->like('educations.notes', ':search'),
                    $qb->expr()->like('educations.activities', ':search'),
                    $qb->expr()->like('educations.degree', ':search'),
                    $qb->expr()->like('educations.fieldOfStudy', ':search'),
                    $qb->expr()->like('institution.name', ':search'),
                    $qb->expr()->like('skills.name', ':search'),
                    $qb->expr()->like('experiences.title', ':search'),
                    $qb->expr()->like('experiences.description', ':search'),
                    $qb->expr()->like('experiences.summary', ':search'),
                    $qb->expr()->like('company.name', ':search')
                )
            )
                ->setParameter('search', '%'.$params['search'].'%');
        }

        //by industry
        if (!empty($params['top_category'])) {
            $qb->andWhere(
                $qb->expr()->eq('industry.id', ':industry_id')
            )
                ->setParameter('industry_id', $params['top_category']);
        } elseif (!empty($params['industries']) && is_array($params['industries'])) {
            $qb->andWhere(
                $qb->expr()->in('industry.id', ':industry_ids')
            )
                ->setParameter('industry_ids', $params['industries']);
        }

        //by company
        if (!empty($params['companies']) && is_array($params['companies'])) {
            $qb->andWhere(
                $qb->expr()->in('company.id', ':company_ids')
            )
                ->setParameter('company_ids', $params['companies']);
        }

        //by price range
        if (!empty($params['prices'])
            && is_array($params['prices'])
            && !empty($priceGroups)
            && is_array($priceGroups)
        ) {
            $piceGroupArray = [];
            $field = 'expert.price';

            foreach ($params['prices'] as $priceGroupId) {
                if (empty($priceGroups[$priceGroupId])) {
                    continue;
                }
                $pGroup = &$priceGroups[$priceGroupId];
                $orX = $qb->expr()->orx();

                switch (true) {
                    case (isset($pGroup['max']) && isset($pGroup['min'])):
                        $condition = $qb->expr()->between($field, ':price_min', ':price_max');
                        $qb->setParameter('price_min', $pGroup['min']);
                        $qb->setParameter('price_max', $pGroup['max']);
                        break;
                    case (isset($pGroup['max'])):
                        $condition = $qb->expr()->lt($field, ':price_max');
                        $qb->setParameter('price_max', $pGroup['max']);
                        break;
                    case (isset($pGroup['min'])):
                        $condition = $qb->expr()->gt($field, ':price_min');
                        $qb->setParameter('price_min', $pGroup['min']);
                        break;
                }
                if (!$condition) {
                    continue;
                }
                $orX->add($condition);
            }

            if ($orX->count()) {
                $qb->andWhere(
                    $orX
                );
            }
        }

        if (! empty($params['rating']) && is_array($params['rating'])) {

            $rating = intval(current($params['rating']));
            // get the integer value between 1 and (max rating - 1)
            $rating = max(1, min($maxRating - 1, $rating));

            $qb->andWhere($qb->expr()->gte('expert.averageRating', ':rating'));
            $qb->setParameter('rating', $rating);
        }

        return $qb;
    }

    /**
     * Get actual "price range groups" by expert ids
     *
     * @param array $ids
     * @param array $priceGroups
     *
     * @return array|null
     */
    public function getActualPriceGroupsByExpertIdsAndPriceGroups(array $ids, array $priceGroups)
    {
        if (empty($ids)) {
            return null;
        }

        $table = $this->getClassMetadata()->getTableName();

        $query = 'SELECT ';
        $query .= '(CASE ';

        foreach ($priceGroups as $id => $_params) {
            $alias = '';

            $query .= ' when expert.price ';

            if (isset($_params['min']) && isset($_params['max'])) {
                $query .= 'BETWEEN '.$_params['min'].' AND '.$_params['max'];
            } else {
                if (isset($_params['min'])) {
                    $query .= '> '.$_params['min'];
                } else {
                    $query .= '< '.$_params['max'];
                }
            }
            $query .= " then '".$id."' \n";

        }
        $query .= "else '' End) as group_id";
        $query .= ", count(expert.id) as experts_count";
        $query .= " FROM ".$table." expert";
        $query .= " WHERE expert.id IN (:ids)";
        $query .= " Group By group_id";

        $rsm = new ResultSetMapping();
        $rsm->addScalarResult('group_id', 'id')
            ->addScalarResult('experts_count', 'experts_count');


        $query = $this->_em->createNativeQuery($query, $rsm);
        $query->setParameter('ids', $ids);

        $resalt = $query->getScalarResult();

        // name param to result aray
        foreach ($resalt as $key => &$_value) {
            if (empty($_value['id']) || !isset($_value['experts_count'])) {
                unset($resalt[$key]);
                continue;
            }
            $id = $_value['id'];
            $_value['name'] = $priceGroups[$id]['name'];
        }


        return $resalt;
    }

    /**
     * Get rating counts for search
     * 
     * @param array $expertsIds description - experts to pick rows from
     * @return array
     */
    public function getAllRatingStages($expertsIds = [], $maxRating)
    {
        if (empty($expertsIds) || ! is_array($expertsIds)) {
            return [];
        }

        // use native because doctrine does not support FLOOR
        $sql = "SELECT FLOOR(average_rating) as rating_stage, COUNT(*) as rating_count
                FROM experts expert
                WHERE average_rating IS NOT NULL 
                AND id IN (:ids) 
                GROUP BY rating_stage";

        $rsm = new ResultSetMapping;
        $rsm->addScalarResult('rating_stage', 'stage');
        $rsm->addScalarResult('rating_count', 'count');

        $query = $this->_em->createNativeQuery($sql, $rsm);
        $query->setParameter('ids', $expertsIds);

        $stages = $query->getScalarResult();

        // now we get the result with the number of experts in range
        // but we need to get for example expert with the rating "2 and more", "3 and more"
        // for example, as the user has rating 4+, seems that he has also 3+ and 2+ and 1+
        // as 4 > 3 && 4 > 2 && 4 > 1
        // so we need to sum up all lower ratings

        $rating = [];

        while ($stage = array_shift($stages)) {
            // calculate tje sum for all the columns left and add current stage count
            $count = array_sum(array_values(ArrayUtils::pluck($stages, 'count'))) + $stage['count'];
            if (! $count) {
                continue;
            }
            $rating[$stage['stage']] = [
                'id' => $stage['stage'],
                'name' => 'Rating ' . $stage['stage'] . ' & Up',
                'experts_count' => $count,
                'max_rating' => $maxRating,
            ];
        }

        // display rating from higher to lower
        $rating = array_reverse($rating);

        return $rating;
    }


}
