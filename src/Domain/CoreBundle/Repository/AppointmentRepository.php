<?php

namespace Domain\CoreBundle\Repository;

use Doctrine\ORM\EntityRepository;
use Doctrine\ORM\QueryBuilder;
use Doctrine\ORM\Query\ResultSetMapping;
use Domain\CoreBundle\Entity\Expert;
use Domain\CoreBundle\Entity\User;
use Domain\CoreBundle\Entity\Appointment;
use DateTime;

/**
 * AppointmentRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class AppointmentRepository extends EntityRepository
{
    /**
     * Find completed appointment for expert and appointment id
     *
     * @param int $appointmentId
     * @param \Domain\CoreBundle\Entity\Expert $expert
     *
     * @return \Domain\CoreBundle\Entity\Appointment
     */
    public function findCompletedByIdAndExpert($appointmentId, Expert $expert)
    {
        $builder = $this->createQueryBuilder('appointment');

        $builder->where('appointment.id = :id')
            ->andWhere('appointment.expert = :expert')
            ->andWhere('appointment.status >= :status');

        $builder->setParameters([
            'id'     => $appointmentId,
            'expert' => $expert,
            'status' => Appointment::STATUS_COMPLETED
        ]);

        return $builder->getQuery()->getOneOrNullResult();
    }

    /**
     * Find completed or ended appointment for expert and appointment id
     *
     * @param int $appointmentId
     * @param \Domain\CoreBundle\Entity\Expert $expert
     *
     * @return \Domain\CoreBundle\Entity\Appointment
     */
    public function findAlmostCompletedByIdAndExpert($appointmentId, Expert $expert)
    {
        $qb = $this->createQueryBuilder('appointment');

        $nowDate = new DateTime('now');

        $qb->where('appointment.id = :id')
            ->andWhere('appointment.expert = :expert')
            ->andWhere($qb->expr()->orX(
                    $qb->expr()->gte('appointment.status', ':status'),
                    $qb->expr()->lt('appointment.endDate', ':nowDate')
                ))
        ;

        $qb->setParameters([
                'id'     => $appointmentId,
                'expert' => $expert,
                'status' => Appointment::STATUS_COMPLETED,
                'nowDate' => $nowDate,
            ]);

        return $qb->getQuery()->getOneOrNullResult();
    }

    /**
     * Find completed appointment for candidate and appointment id
     *
     * @param int $appointmentId
     * @param \Domain\CoreBundle\Entity\User $candidate
     *
     * @return \Domain\CoreBundle\Entity\Appointment
     */
    public function findCompletedByIdAndCandidate($appointmentId, User $candidate)
    {
        $builder = $this->createQueryBuilder('appointment');

        $builder->where('appointment.id = :id')->andWhere('appointment.candidate = :candidate')->andWhere('appointment.status >= :status');

        $builder->setParameters([
            'id'        => $appointmentId,
            'candidate' => $candidate,
            'status'    => Appointment::STATUS_COMPLETED
        ]);

        return $builder->getQuery()->getOneOrNullResult();
    }

    /**
     * Find completed appointment for candidate and appointment id
     *
     * @param int $appointmentId
     * @param \Domain\CoreBundle\Entity\User $candidate
     *
     * @return \Domain\CoreBundle\Entity\Appointment
     */
    public function findAlmostCompletedByIdAndCandidate($appointmentId, User $candidate)
    {
        $qb = $this->createQueryBuilder('appointment');

        $nowDate = new DateTime('now');

        $qb->where('appointment.id = :id')
            ->andWhere('appointment.candidate = :candidate')
            ->andWhere($qb->expr()->orX(
                    $qb->expr()->gte('appointment.status', ':status'),
                    $qb->expr()->lt('appointment.endDate', ':nowDate')
                ))
        ;

        $qb->setParameters([
                'id'        => $appointmentId,
                'candidate' => $candidate,
                'status'    => Appointment::STATUS_COMPLETED,
                'nowDate' => $nowDate,
            ]);

        return $qb->getQuery()->getOneOrNullResult();
    }

    /**
     * Get appointments by time range and expert
     *
     * @param Expert $expert
     * @param DateTime $rangeStart
     * @param DateTime $rangeEnd
     *
     * @return array
     */
    public function getByTimeRange(Expert $expert, DateTime $rangeStart, DateTime $rangeEnd)
    {

        return $this->qbByTimeRange($expert, $rangeStart, $rangeEnd)->getQuery()->getArrayResult();
    }

    /**
     * Get appointments by time range (start & and time) and expert
     *
     * @param Expert $expert
     * @param DateTime $rangeStart
     * @param DateTime $rangeEnd
     *
     * @return \Doctrine\ORM\QueryBuilder
     */
    protected function qbByTimeRange(Expert $expert, DateTime $rangeStart, DateTime $rangeEnd)
    {
        $blockedStatuses = [
            Appointment::STATUS_APPROVED,
            Appointment::STATUS_COMPLETED,
            Appointment::STATUS_FEEDBACKED,
        ];

        $qb = $this->createQueryBuilder('appointment');

        $qb->andWhere($qb->expr()->eq('appointment.expert', ':expert'));
        $qb->andWhere($qb->expr()->gte('appointment.startDate', ':start'));
        $qb->andWhere($qb->expr()->lt('appointment.startDate', ':end'));
        $qb->andWhere(
            $qb->expr()->orX(
                $qb->expr()->in('appointment.status', ':statuses'),
                $qb->expr()->andX(
                    $qb->expr()->eq('appointment.status', ':paid_status'),
                    $qb->expr()->eq('appointment.requireCandidate', ':require_candidate')
                )
            )
        );

        $qb->setParameter(':expert', $expert)
            ->setParameter(':start', $rangeStart)
            ->setParameter(':end', $rangeEnd)
            ->setParameter(':statuses', $blockedStatuses)
            ->setParameter(':paid_status', Appointment::STATUS_PAID)
            ->setParameter(':require_candidate', true)
        ;

        return $qb;
    }

    /**
     * Get count of appointments by time range and expert
     *
     * @param Expert $expert
     * @param DateTime $rangeStart
     * @param DateTime $rangeEnd
     *
     * @return int
     */
    public function getCountByTimeRange(Expert $expert, DateTime $rangeStart, DateTime $rangeEnd)
    {
        $qb = $this->qbByTimeRange($expert, $rangeStart, $rangeEnd);

        $qb->select($qb->expr()->count('appointment.id'));

        return (int)$qb->getQuery()->getSingleScalarResult();
    }

    /**
     * Get QueryBuilder with preset conditions for Appointments Schduler Service
     *
     * @param DateTime $startDate
     * @param DateTime $endDate
     * @param string $orderDirection
     *
     * @return QueryBuilder
     */
    public function getQBForAppointmentsSchdulerService(DateTime $startDate, DateTime $endDate, $orderDirection)
    {
        $nowDate = new Datetime;

        $limitedStatuses = [
            Appointment::STATUS_APPROVED,
            Appointment::STATUS_COMPLETED,
            Appointment::STATUS_FEEDBACKED,
        ];

        $unlimitedStatuses   = $limitedStatuses;
        $unlimitedStatuses[] = Appointment::STATUS_PAID;

        /*        $selectFields = [
                    'appointment.id',
                    'appointment.type',
                    'appointment.startDate',
                    'appointment.endDate',
                    'appointment.totalPrice',
                    'appointment.status',
                ];*/

        $qb = $this->createQueryBuilder('appointment');
        //$qb->select($selectFields)
        $qb->leftJoin('appointment.candidate', 'candidate')
            ->leftJoin('appointment.expert', 'expert')
            ->leftJoin('expert.user', 'expertUser')
            ->addSelect([
                'candidate.first_name as candidate_first_name',
                'candidate.last_name as candidate_last_name',
                'expertUser.first_name as expert_first_name',
                'expertUser.last_name as expert_last_name',
            ]);
        $qb->where(
            $qb->expr()->orX(
                $qb->expr()->andX(
                    $qb->expr()->lte('appointment.startDate', ':now_date'),
                    $qb->expr()->in('appointment.status', ':limited_statuses')
                ),
                $qb->expr()->andX(
                    $qb->expr()->gt('appointment.startDate', ':now_date'),
                    $qb->expr()->in('appointment.status', ':unlimited_statuses')
                )
            )
        )->setParameter('now_date', $nowDate)
            ->setParameter('limited_statuses', $limitedStatuses)
            ->setParameter('unlimited_statuses', $unlimitedStatuses)
            ->andWhere($qb->expr()->between('appointment.startDate', ':start_date', ':end_date'))
            ->setParameter('start_date', $startDate)->setParameter('end_date', $endDate)
            ->orderBy('appointment.startDate', $orderDirection);

        return $qb;
    }

    /**
     * Set expert condition to QueryBuilder
     *
     * @param QueryBuilder $qb
     * @param Expert $expert
     */
    public function setExpertToQB(QueryBuilder $qb, Expert $expert)
    {
        $qb->andWhere($qb->expr()->eq('appointment.expert', ':expert'))->setParameter('expert', $expert);
    }

    /**
     * Set candidate condition to QueryBuilder
     *
     * @param QueryBuilder $qb
     * @param User $candidate
     */
    public function setCandidateToQB(QueryBuilder $qb, User $candidate)
    {
        $qb->andWhere($qb->expr()->eq('appointment.candidate', ':candidate'))->setParameter('candidate', $candidate);
    }

    /**
     * Get competitors for current appointment
     *
     * @param Appointment $appointment
     *
     * @return QueryBuilder
     */
    public function getQBCompetitors(Appointment $appointment)
    {
        $qb = $this->createQueryBuilder('appointment');
        $qb
            ->where($qb->expr()->eq('appointment.status', Appointment::STATUS_PAID))
            ->andWhere($qb->expr()->gt('appointment.startDate', ':now_date'))
            ->andWhere(
                $qb->expr()->orX(
                    $qb->expr()->andX(
                        $qb->expr()->lt('appointment.startDate', ':start_date'),
                        $qb->expr()->gt('appointment.endDate', ':start_date')
                    ),
                    $qb->expr()->andX(
                        $qb->expr()->lt('appointment.startDate', ':end_date'),
                        $qb->expr()->gt('appointment.endDate', ':end_date')
                    ),
                    $qb->expr()->andX(
                        $qb->expr()->eq('appointment.startDate', ':start_date'),
                        $qb->expr()->eq('appointment.endDate', ':end_date')
                    )
                )
            )
            ->andWhere($qb->expr()->neq('appointment.id', ':id'))
        ;

        $nowDate = new DateTime();

        $qb
            ->setParameter('id', $appointment->getId())
            ->setParameter('now_date', $nowDate)
            ->setParameter('start_date', $appointment->getStartDate())
            ->setParameter('end_date', $appointment->getEndDate())
        ;

        return $qb;
    }

    /**
     * Get QueryBuilder of all appointments not reminded to ....
     *
     * @return QueryBuilder
     */
    public function getQBNotNotificatedBase()
    {
        $nowDate = new DateTime();

        $qb = $this->createQueryBuilder('appointment');

        $qb->where(
            $qb->expr()->andX(
                    $qb->expr()->eq('appointment.status', ':approved_status'),
                    $qb->expr()->gt('appointment.startDate', ':now_date'),
                    $qb->expr()->eq('notificationOptions.remindMeEmail', ':remindMeEmail'),
                    $qb->expr()->lte('appointment.startDate', 'dateadd(:now_date, INTERVAL notificationOptions.remindMeInterval SECOND)')
                )
            )
            ->leftJoin('appointment.notification', 'notification')
            ->setParameters([
                    'approved_status' => Appointment::STATUS_APPROVED,
                    'now_date' => $nowDate,
                    'remindMeEmail' => 1,
                    'not_notified' => 0
                ]);
        ;

        return $qb;
    }

    /**
     * Get all appointments not reminded to candidate
     *
     * @return array
     */
    public function getNotNotificatedForCandidate()
    {
        $qb = $this->getQBNotNotificatedBase();
        $qb->andWhere($qb->expr()->orX(
                $qb->expr()->isNull('notification.candidateNotified'),
                $qb->expr()->eq('notification.candidateNotified', ':not_notified')
            ))
            ->innerJoin('appointment.candidate', 'user')
            ->innerJoin('user.notificationOptions', 'notificationOptions')
            ->addSelect('user')
        ;

        return $qb->getQuery()->getResult();
    }

    /**
     * Get all appointments not reminded to expert
     *
     * @return array
     */
    public function getNotNotificatedForExpert()
    {
        $qb = $this->getQBNotNotificatedBase();
        $qb->andWhere($qb->expr()->orX(
                $qb->expr()->isNull('notification.expertNotified'),
                $qb->expr()->eq('notification.expertNotified', ':not_notified')
            ))
            ->innerJoin('appointment.expert', 'expert')
            ->innerJoin('expert.user', 'user')
            ->innerJoin('user.notificationOptions', 'notificationOptions')
            ->addSelect('expert')
            ->addSelect('user')
        ;

        return $qb->getQuery()->getResult();
    }

    /**
     * Get appointments for completion
     *
     * @return array
     */
    public function getForCompletion()
    {
        $nowDate = new DateTime();

        $qb = $this->createQueryBuilder('appointment');
        $qb->where($qb->expr()->andX(
                $qb->expr()->lte('appointment.endDate', ':now_date'),
                $qb->expr()->eq('appointment.status', ':approved_status')
            ))
        ->setParameters([
                    'now_date' => $nowDate,
                    'approved_status' => Appointment::STATUS_APPROVED
                ])
        ;

        return $qb->getQuery()->getResult();
    }

    public function getNotAutoNotificated($interval)
    {
        $nowDate = new DateTime();

        $qb = $this->createQueryBuilder('appointment');

        $qb
            ->leftJoin('appointment.notification', 'notification')
            ->where(
                $qb->expr()->andX(
                    $qb->expr()->eq('appointment.status', ':approved_status'),
                    $qb->expr()->gt('appointment.startDate', ':now_date'),
                    //$qb->expr()->eq('notificationOptions.remindMeEmail', ':remindMeEmail'),
                    $qb->expr()->lte('appointment.startDate', 'dateadd(:now_date, INTERVAL :interval SECOND)'),
                    $qb->expr()->orX(
                        $qb->expr()->isNull('notification.appointment'),
                        $qb->expr()->eq('notification.beforeStartCandidate', ':not_notified'),
                        $qb->expr()->eq('notification.beforeStartExpert', ':not_notified')
                    )
                )
            )
            ->setParameters([
                        'approved_status' => Appointment::STATUS_APPROVED,
                        'now_date' => $nowDate,
                        'not_notified' => 0,
                        'interval' => $interval,
                    ]);
            ;

        return $qb->getQuery()->getResult();
    }

    /**
     * Get active appointment count grouped by expert and start date
     *
     * @param array $expertIds
     * @param DateTime $startDate
     * @param DateTime $endDate
     *
     * @return array
     */
    public function getCountAppointmentsPerDayAndExpert(array $expertIds, DateTime $startDate, DateTime $endDate)
    {
        if (empty($expertIds)) {
            return [];
        }
        
        $sql = "SELECT count(a.id) as count, a.expert_id, DATE_FORMAT(a.start_date, '%Y-%m-%d') as date
        FROM appointments a
        WHERE a.expert_id IN (:expertIds)
        AND a.status IN (:statuses)
        AND a.start_date BETWEEN :startDate AND :endDate
        GROUP BY a.expert_id, date";

        $rsm = new ResultSetMapping;
        $rsm->addScalarResult('count', 'count');
        $rsm->addScalarResult('expert_id', 'expert_id');
        $rsm->addScalarResult('date', 'date');

        $query = $this->_em->createNativeQuery($sql, $rsm);
        $query->setParameters([
                'expertIds' => $expertIds,
                'startDate' => $startDate,
                'endDate' => $endDate,
                'statuses' => [
                    Appointment::STATUS_APPROVED,
                    Appointment::STATUS_COMPLETED,
                    Appointment::STATUS_FEEDBACKED,
                ]
            ]);

        return $query->getScalarResult();
    }

    /**
     * @return array
     */
    public function getOverdue()
    {
        $nowDate = new DateTime();

        $qb = $this->createQueryBuilder('appointment');
        $qb->where(
            $qb->expr()->andX(
                $qb->expr()->eq('appointment.status', ':status'),
                $qb->expr()->lt('appointment.startDate', ':now')
            )
        )
            ->setParameters([
                'status' => Appointment::STATUS_PAID,
                'now' => $nowDate,
            ])
        ;

        return $qb->getQuery()->getResult();
    }

}
